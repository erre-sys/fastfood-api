/* ===========================
   FastFood DB
   Diseño centrado en los casos de uso esenciales: compras simples, inventario actual, platos/recetas y pedidos con extras.
   Menos tablas, menos fricción con JPA/DSL.
   FastFood DB - Patch V2 (MySQL 8)
   Requiere esquema base 'fastfood_min' ya creado.
   Objetivos: Caja, Promos programadas (flag en platos),
              Kardex con % descuento, SP/Triggers sin ENUM/BOOL.
   =========================== */

SET sql_mode = 'STRICT_TRANS_TABLES,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION';
SET NAMES utf8mb4 COLLATE utf8mb4_0900_ai_ci;

CREATE DATABASE IF NOT EXISTS fastfood_min
  DEFAULT CHARACTER SET utf8mb4
  DEFAULT COLLATE utf8mb4_0900_ai_ci;
USE fastfood_min;


CREATE TABLE grupo_ingrediente (
  grupo_ingrediente_id BIGINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,
  nombre               VARCHAR(120) NOT NULL UNIQUE
) ENGINE=InnoDB;

CREATE TABLE ingredientes (
  ingrediente_id BIGINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,
  grupo_ingrediente_id BIGINT UNSIGNED NOT NULL,
  codigo         VARCHAR(40) NOT NULL UNIQUE,
  nombre         VARCHAR(160) NOT NULL,
  unidad         VARCHAR(16) NOT NULL,
  es_extra       VARCHAR(1) NOT NULL DEFAULT 'N', -- Si es extra, se puede agregar al plato (validar en la app)
  precio_extra   DECIMAL(12,2) DEFAULT NULL,
  stock_minimo   DECIMAL(12,3) NOT NULL DEFAULT 0,
  activo         VARCHAR(1) NOT NULL DEFAULT 'S',
  CONSTRAINT fk_ing_grupo FOREIGN KEY (grupo_ingrediente_id) REFERENCES grupo_ingrediente(grupo_ingrediente_id)
) ENGINE=InnoDB;

-- Inventario actual (1 fila por ingrediente). La app ajusta en transacción.
CREATE TABLE inventario (
  ingrediente_id BIGINT UNSIGNED PRIMARY KEY,
  stock_actual   DECIMAL(14,3) NOT NULL DEFAULT 0,
  actualizado_en DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  FOREIGN KEY (ingrediente_id) REFERENCES ingredientes(ingrediente_id)
) ENGINE=InnoDB;


CREATE TABLE proveedores (
  proveedor_id  BIGINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,
  nombre        VARCHAR(160) NOT NULL,
  ruc           VARCHAR(20),
  telefono      VARCHAR(40),
  email         VARCHAR(160),
  activo        VARCHAR(1) NOT NULL DEFAULT 'S'
) ENGINE=InnoDB;

CREATE TABLE compra (
  compra_id     BIGINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,
  proveedor_id  BIGINT UNSIGNED NOT NULL,
  fecha         DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  referencia    VARCHAR(80), -- #factura/nota/"URGENTE"
  creado_por_sub VARCHAR(64) NOT NULL, -- Keycloak sub (sin tabla usuarios)
  observaciones VARCHAR(500),
  FOREIGN KEY (proveedor_id) REFERENCES proveedores(proveedor_id)
) ENGINE=InnoDB;

CREATE TABLE compra_item (
  compra_item_id BIGINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,
  compra_id      BIGINT UNSIGNED NOT NULL,
  ingrediente_id BIGINT UNSIGNED NOT NULL,
  cantidad       DECIMAL(14,3) NOT NULL,
  costo_unitario DECIMAL(12,4) NOT NULL,
  FOREIGN KEY (compra_id) REFERENCES compra(compra_id) ON DELETE CASCADE,
  FOREIGN KEY (ingrediente_id) REFERENCES ingredientes(ingrediente_id)
) ENGINE=InnoDB;

-- =====================
-- Platos / Recetas
-- =====================
CREATE TABLE grupo_plato (
  grupo_plato_id BIGINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,
  nombre         VARCHAR(120) NOT NULL UNIQUE
) ENGINE=InnoDB;

CREATE TABLE platos (
  plato_id       BIGINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,
  codigo         VARCHAR(40) NOT NULL UNIQUE,
  nombre         VARCHAR(160) NOT NULL,
  grupo_plato_id BIGINT UNSIGNED NOT NULL,
  precio_base    DECIMAL(12,2) NOT NULL,
  activo         VARCHAR(1) NOT NULL DEFAULT 'S',
  en_promocion   VARCHAR(1) NOT NULL DEFAULT 'N' AFTER activo,
  descuento      DECIMAL(5,2) NOT NULL DEFAULT 0 AFTER en_promocion, -- Indica si el plato está en promoción (la app puede aplicar descuento)
  FOREIGN KEY (grupo_plato_id) REFERENCES grupo_plato(grupo_plato_id)
) ENGINE=InnoDB;

-- Receta: cantidad de ingrediente por 1 unidad del plato
CREATE TABLE receta_item (
  plato_id       BIGINT UNSIGNED NOT NULL,
  ingrediente_id BIGINT UNSIGNED NOT NULL,
  cantidad       DECIMAL(14,3) NOT NULL,
  PRIMARY KEY (plato_id, ingrediente_id),
  FOREIGN KEY (plato_id) REFERENCES platos(plato_id) ON DELETE CASCADE,
  FOREIGN KEY (ingrediente_id) REFERENCES ingredientes(ingrediente_id)
) ENGINE=InnoDB;

-- =====================
-- Pedidos (POS/KDS)
-- =====================
CREATE TABLE pedidos (
  pedido_id      BIGINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,
  estado         VARCHAR(50 ) DEFAULT 'CREADO', -- CREADO, EN_COCINA, LISTO, ENTREGADO, CANCELADO
  total_bruto    DECIMAL(12,2) NOT NULL DEFAULT 0,
  total_extras   DECIMAL(12,2) NOT NULL DEFAULT 0,
  total_neto     DECIMAL(12,2) NOT NULL DEFAULT 0,
  creado_por_sub VARCHAR(64) NOT NULL,
  entregado_por_sub VARCHAR(64) NULL,
  creado_en      DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  entregado_en   DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  actualizado_en DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  INDEX idx_ped_estado (estado)
) ENGINE=InnoDB;

CREATE TABLE pago_cliente (
  pago_cliente_id BIGINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,
  pedido_id      BIGINT UNSIGNED NOT NULL,
  fecha          DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  monto_total    DECIMAL(12,2) NOT NULL,
  metodo         VARCHAR(64) NOT NULL DEFAULT 'EFECTIVO', -- EFECTIVO, TARJETA, TRANSFERENCIA, OTRO
  estado         VARCHAR(1) NOT NULL DEFAULT 'PENDIENTE', -- PENDIENTE, COMPLETADO, CANCELADO, FIADO
  referencia     VARCHAR(80),
  creado_por_sub VARCHAR(64) NOT NULL,
  FOREIGN KEY (pedido_id) REFERENCES pedidos(pedido_id),
  INDEX idx_pago_cli_fecha (fecha)
) ENGINE=InnoDB;

CREATE TABLE pedido_item (
  pedido_item_id BIGINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,
  pedido_id      BIGINT UNSIGNED NOT NULL,
  plato_id       BIGINT UNSIGNED NOT NULL,
  cantidad       INT UNSIGNED NOT NULL,
  precio_unitario DECIMAL(12,2) NOT NULL,
  subtotal       DECIMAL(12,2) NOT NULL,
  descuento_porcentaje DECIMAL(12,2) NOT NULL DEFAULT 0,
  total       DECIMAL(12,2) NOT NULL,
  descuento_pct   DECIMAL(5,2)  NOT NULL DEFAULT 0 ,
  descuento_monto DECIMAL(12,2) NOT NULL DEFAULT 0 ,
  FOREIGN KEY (pedido_id) REFERENCES pedidos(pedido_id) ON DELETE CASCADE,
  FOREIGN KEY (plato_id) REFERENCES platos(plato_id)
) ENGINE=InnoDB;

-- Extras por ítem: permitir sólo ingredientes marcados como es_extra (validar en la app)
CREATE TABLE pedido_item_extra (
  pedido_item_extra_id BIGINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,
  pedido_item_id BIGINT UNSIGNED NOT NULL,
  ingrediente_id BIGINT UNSIGNED NOT NULL,
  cantidad       DECIMAL(14,3) NOT NULL,
  precio_extra   DECIMAL(12,2) NOT NULL,
  FOREIGN KEY (pedido_item_id) REFERENCES pedido_item(pedido_item_id) ON DELETE CASCADE,
  FOREIGN KEY (ingrediente_id) REFERENCES ingredientes(ingrediente_id)
) ENGINE=InnoDB;


-- =====================
-- Pagos a proveedores (simple)
-- =====================
CREATE TABLE pago_proveedor (
  pago_proveedor_id BIGINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,
  proveedor_id  BIGINT UNSIGNED NOT NULL,
  fecha         DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  monto_total   DECIMAL(12,2) NOT NULL,
  metodo        VARCHAR(16) NOT NULL; -- EFECTIVO, TRANSFERENCIA, OTRO
  estado        VARCHAR(20) NOT NULL DEFAULT 'PENDIENTE', -- PEND IENTE, COMPLETADO, CANCELADO, FIADO
  referencia    VARCHAR(80),
  observaciones VARCHAR(500),
  creado_por_sub VARCHAR(64) NOT NULL,
  FOREIGN KEY (proveedor_id) REFERENCES proveedores(proveedor_id)
) ENGINE=InnoDB;


CREATE TABLE IF NOT EXISTS pago_cliente (
  pago_cliente_id BIGINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,
  pedido_id      BIGINT UNSIGNED NOT NULL,
  fecha          DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  monto_total    DECIMAL(12,2) NOT NULL,
  metodo         VARCHAR(16) NOT NULL, -- 'EFECTIVO','TARJETA','TRANSFERENCIA','OTRO' (libre)
  referencia     VARCHAR(80),
  creado_por_sub VARCHAR(64) NOT NULL,
  FOREIGN KEY (pedido_id) REFERENCES pedidos(pedido_id),
  INDEX idx_pago_cli_fecha (fecha),
  INDEX idx_pago_cli_ped (pedido_id)
) ENGINE=InnoDB;

CREATE OR REPLACE VIEW v_caja_movimientos AS
SELECT fecha, 'INGRESO' AS tipo, metodo, monto_total AS monto FROM pago_cliente
UNION ALL
SELECT fecha, 'EGRESO'  AS tipo, metodo, monto_total       FROM pago_proveedor;

/* -------------------------------------
   2) Kardex (movimientos de inventario)
   ------------------------------------- */
CREATE TABLE IF NOT EXISTS inventario_mov (
  inventario_mov_id BIGINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,
  ingrediente_id    BIGINT UNSIGNED NOT NULL,
  fecha             DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  tipo              VARCHAR(12) NOT NULL,         -- 'COMPRA','CONSUMO','AJUSTE'
  cantidad          DECIMAL(14,3) NOT NULL,       -- +entrada / -salida
  descuento_pct     DECIMAL(5,2) NOT NULL DEFAULT 0, -- % promedio aplicado al consumo
  referencia        VARCHAR(80),
  compra_item_id    BIGINT UNSIGNED NULL,
  pedido_id         BIGINT UNSIGNED NULL,
  FOREIGN KEY (ingrediente_id) REFERENCES ingredientes(ingrediente_id),
  INDEX idx_inv_mov_fecha (fecha),
  INDEX idx_inv_mov_ing (ingrediente_id),
  INDEX idx_inv_mov_ped (pedido_id),
  INDEX idx_inv_mov_comp (compra_item_id)
) ENGINE=InnoDB;

-- (opcional) CHECKs ligeros
DROP CHECK IF EXISTS chk_inv_tipo;
ALTER TABLE inventario_mov
  ADD CONSTRAINT chk_inv_tipo CHECK (tipo IN ('COMPRA','CONSUMO','AJUSTE'));

/* -------------------------------------
   3) Promos programadas (flag en platos)
   ------------------------------------- */
CREATE TABLE IF NOT EXISTS promo_programada (
  promo_id       BIGINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,
  plato_id       BIGINT UNSIGNED NOT NULL,
  fecha_inicio   DATETIME NOT NULL,
  fecha_fin      DATETIME NOT NULL,
  descuento_pct  DECIMAL(5,2) NOT NULL,  -- 0..100
  estado         VARCHAR(1) NOT NULL DEFAULT 'A',  -- A/I
  creado_por_sub VARCHAR(64) NOT NULL,
  FOREIGN KEY (plato_id) REFERENCES platos(plato_id),
  INDEX idx_promo_plato (plato_id),
  INDEX idx_promo_rango (fecha_inicio, fecha_fin)
) ENGINE=InnoDB;

DROP CHECK IF EXISTS chk_promo_estado;
ALTER TABLE promo_programada
  ADD CONSTRAINT chk_promo_estado CHECK (estado IN ('A','I'));

DROP CHECK IF EXISTS chk_promo_pct;
ALTER TABLE promo_programada
  ADD CONSTRAINT chk_promo_pct CHECK (descuento_pct >= 0 AND descuento_pct <= 100);


-- =====================
-- Reglas de uso (sin triggers)
-- =====================
-- 1) RECEPCIÓN DE COMPRA (transaccional):
--    - Insert en compra y compra_item.
--    - Por cada item: UPDATE inventario SET stock_actual = stock_actual + cantidad (o INSERT si no existe).
-- 2) CAMBIO DE ESTADO A ENTREGADO (transaccional):
--    - Calcular consumo por ingrediente = \sum(receta_item.cantidad * pedido_item.cantidad) + \sum(pedido_item_extra.cantidad)
--    - Validar stock_actual suficiente para cada ingrediente.
--    - Descontar: UPDATE inventario SET stock_actual = stock_actual - consumo_por_ingrediente.
--    - UPDATE pedidos SET estado='ENTREGADO', entregado_por_sub=?, actualizado_en=NOW().
-- 3) "Compras urgentes": crear compra con referencia='URGENTE'.

-- =====================
-- Datos de ejemplo
-- =====================
INSERT INTO grupo_ingrediente(nombre) VALUES ('Carnes'),('Vegetales'),('Lacteos'),('Salsas');

INSERT INTO ingredientes(codigo,nombre,grupo_ingrediente_id,unidad,es_extra,precio_extra,stock_minimo)
SELECT 'CARNE','Carne de res',(SELECT grupo_ingrediente_id FROM grupo_ingrediente WHERE nombre='Carnes'),'kg',0,NULL,1
UNION ALL
SELECT 'QUESO','Queso cheddar',(SELECT grupo_ingrediente_id FROM grupo_ingrediente WHERE nombre='Lacteos'),'kg',1,0.50,0.5
UNION ALL
SELECT 'CEBOLLA','Cebolla',(SELECT grupo_ingrediente_id FROM grupo_ingrediente WHERE nombre='Vegetales'),'kg',1,0.20,0.2
UNION ALL
SELECT 'SALSA','Salsa especial',(SELECT grupo_ingrediente_id FROM grupo_ingrediente WHERE nombre='Salsas'),'ml',0,NULL,0.5;

-- Crea inventario inicial (0) para todos
INSERT INTO inventario(ingrediente_id, stock_actual)
SELECT ingrediente_id, 0 FROM ingredientes;

INSERT INTO proveedores(nombre,ruc,telefono,email) VALUES ('Proveedor Central','1099999999001','0999999999','compras@central.ec');

INSERT INTO grupo_plato(nombre) VALUES ('Hamburguesas');
INSERT INTO platos(codigo,nombre,grupo_plato_id,precio_base)
SELECT 'HB-CLASS','Hamburguesa Clásica',grupo_plato_id,5.00 FROM grupo_plato WHERE nombre='Hamburguesas';

-- Receta de la HB-CLASS
INSERT INTO receta_item(plato_id,ingrediente_id,cantidad)
SELECT p.plato_id, i.ingrediente_id, x.cant
FROM (
  SELECT 'CARNE' cod, 0.150 cant UNION ALL  -- 150 g
  SELECT 'QUESO', 0.020 UNION ALL           -- 20 g
  SELECT 'CEBOLLA', 0.015 UNION ALL         -- 15 g
  SELECT 'SALSA', 20                        -- 20 ml
) x
JOIN ingredientes i ON i.codigo = x.cod
JOIN platos p ON p.codigo = 'HB-CLASS';

-- =====================
-- Ejemplos de uso (comentados)
-- =====================
-- 1) Compra y carga de stock (transacción en app):
-- INSERT INTO compra(proveedor_id, referencia, creado_por_sub) VALUES (1,'FAC-0001','sub-keycloak-1');
-- SET @c := LAST_INSERT_ID();
-- INSERT INTO compra_item(compra_id, ingrediente_id, cantidad, costo_unitario)
-- SELECT @c, ingrediente_id, cant, costo FROM (
--   SELECT 'CARNE' cod, 10.000 cant, 5.20 costo UNION ALL
--   SELECT 'QUESO',  5.000,      6.00       UNION ALL
--   SELECT 'CEBOLLA',3.000,      0.80       UNION ALL
--   SELECT 'SALSA',  5000,       0.01
-- ) x JOIN ingredientes i ON i.codigo = x.cod;
-- -- Ajustar inventario (hacerlo en la misma transacción):
-- UPDATE inventario inv JOIN ingredientes i ON i.codigo='CARNE'  AND inv.ingrediente_id=i.ingrediente_id SET inv.stock_actual=inv.stock_actual+10.000;
-- UPDATE inventario inv JOIN ingredientes i ON i.codigo='QUESO'  AND inv.ingrediente_id=i.ingrediente_id SET inv.stock_actual=inv.stock_actual+5.000;
-- UPDATE inventario inv JOIN ingredientes i ON i.codigo='CEBOLLA' AND inv.ingrediente_id=i.ingrediente_id SET inv.stock_actual=inv.stock_actual+3.000;
-- UPDATE inventario inv JOIN ingredientes i ON i.codigo='SALSA'   AND inv.ingrediente_id=i.ingrediente_id SET inv.stock_actual=inv.stock_actual+5000;

-- 2) Pedido con 2 HB-CLASS y extra de queso (10 g por ítem)
-- INSERT INTO pedidos(creado_por_sub) VALUES ('sub-keycloak-1');
-- SET @p := LAST_INSERT_ID();
-- INSERT INTO pedido_item(pedido_id, plato_id, cantidad, precio_unitario, subtotal)
-- SELECT @p, p.plato_id, 2, p.precio_base, 2*p.precio_base FROM platos p WHERE p.codigo='HB-CLASS';
-- INSERT INTO pedido_item_extra(pedido_item_id, ingrediente_id, cantidad, precio_extra)
-- SELECT pi.pedido_item_id, i.ingrediente_id, 0.010*2, i.precio_extra
-- FROM pedido_item pi JOIN platos p ON p.plato_id=pi.plato_id AND p.codigo='HB-CLASS'
-- JOIN ingredientes i ON i.codigo='QUESO'
-- WHERE pi.pedido_id=@p;
-- UPDATE pedidos SET total_bruto=(SELECT SUM(subtotal) FROM pedido_item WHERE pedido_id=@p),
--                    total_extras=(SELECT COALESCE(SUM(precio_extra),0) FROM pedido_item_extra WHERE pedido_item_id IN (SELECT pedido_item_id FROM pedido_item WHERE pedido_id=@p)),
--                    total_neto=total_bruto+total_extras,
--                    estado='LISTO' WHERE pedido_id=@p;

-- 3) ENTREGAR pedido (transacción en app):
-- -- Calcular consumo por ingrediente y validar stock >= consumo
-- -- Si ok: descontar de inventario y marcar ENTREGADO
-- UPDATE inventario inv
-- JOIN (
--   SELECT r.ingrediente_id, SUM(r.cantidad*pi.cantidad) + COALESCE(SUMEX.cant_extra,0) AS consumo
--   FROM pedido_item pi
--   JOIN receta_item r ON r.plato_id=pi.plato_id
--   LEFT JOIN (
--     SELECT pie.ingrediente_id, SUM(pie.cantidad) AS cant_extra
--     FROM pedido_item_extra pie
--     JOIN pedido_item pii ON pii.pedido_item_id=pie.pedido_item_id
--     WHERE pii.pedido_id=@p
--     GROUP BY pie.ingrediente_id
--   ) SUMEX ON SUMEX.ingrediente_id=r.ingrediente_id
--   WHERE pi.pedido_id=@p
--   GROUP BY r.ingrediente_id
-- ) x ON x.ingrediente_id=inv.ingrediente_id
-- SET inv.stock_actual = inv.stock_actual - x.consumo;
-- UPDATE pedidos SET estado='ENTREGADO', entregado_por_sub='sub-keycloak-1' WHERE pedido_id=@p;

-- FIN

-- Patch para fastfood_min: triggers y SP de cambio de estado
-- Requiere haber creado previamente el esquema "fastfood_min" del archivo Fastfood Mysql8 Minimal

-- =====================
-- Trigger: crear fila de inventario al crear ingrediente
-- =====================
DELIMITER $$
CREATE TRIGGER trg_ingredientes_ai
AFTER INSERT ON ingredientes
FOR EACH ROW
BEGIN
  INSERT IGNORE INTO inventario(ingrediente_id, stock_actual) VALUES (NEW.ingrediente_id, 0);
END $$
DELIMITER ;

-- =====================
-- Trigger: sumar al inventario cuando entra una compra_item
-- =====================
DELIMITER $$
CREATE TRIGGER trg_compra_item_ai
AFTER INSERT ON compra_item
FOR EACH ROW
BEGIN
  INSERT INTO inventario(ingrediente_id, stock_actual)
  VALUES (NEW.ingrediente_id, NEW.cantidad)
  ON DUPLICATE KEY UPDATE stock_actual = stock_actual + NEW.cantidad;

  INSERT INTO inventario_mov(ingrediente_id, tipo, cantidad, referencia, compra_item_id)
  VALUES (NEW.ingrediente_id, 'COMPRA', NEW.cantidad, CONCAT('COMPRA #',NEW.compra_id), NEW.compra_item_id);
END $$
DELIMITER ;

-- =====================
-- Guard: prohibir ENTREGAR por UPDATE directo (obliga usar el SP)
-- =====================
DELIMITER $$
CREATE TRIGGER trg_pedidos_bu_estado_guard
BEFORE UPDATE ON pedidos
FOR EACH ROW
BEGIN
  IF (NEW.estado = 'ENTREGADO' AND OLD.estado <> 'ENTREGADO') THEN
    IF (@bypass_entrega IS NULL OR @bypass_entrega <> 1) THEN
      SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Usa sp_pedido_cambiar_estado para ENTREGAR';
    END IF;
  END IF;
END $$
DELIMITER ;

-- =====================
-- Índices útiles para consumo
-- =====================
CREATE INDEX idx_pedido_item_pedido ON pedido_item(pedido_id);
CREATE INDEX idx_pedido_item_extra_pi ON pedido_item_extra(pedido_item_id);
CREATE INDEX idx_receta_item_plato ON receta_item(plato_id);

-- =====================
-- SP: cambiar estado (y descontar stock al ENTREGAR)
-- =====================
DELIMITER $$
CREATE PROCEDURE sp_pedido_cambiar_estado (
  IN p_pedido_id BIGINT,
  IN p_estado_nuevo ENUM('CREADO','EN_COCINA','LISTO','ENTREGADO','CANCELADO'),
  IN p_usuario_sub VARCHAR(64)
)
BEGIN
  DECLARE v_estado_actual ENUM('CREADO','EN_COCINA','LISTO','ENTREGADO','CANCELADO');

  START TRANSACTION;

  SELECT estado INTO v_estado_actual FROM pedidos WHERE pedido_id = p_pedido_id FOR UPDATE;

  IF v_estado_actual IS NULL THEN
    ROLLBACK; SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Pedido no existe';
  END IF;

  IF v_estado_actual = p_estado_nuevo THEN
    COMMIT; RETURN;
  END IF;

  IF v_estado_actual IN ('CANCELADO','ENTREGADO') THEN
    ROLLBACK; SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Pedido ya finalizado';
  END IF;

  IF p_estado_nuevo = 'ENTREGADO' THEN
    -- Calcular consumo
    CREATE TEMPORARY TABLE IF NOT EXISTS tmp_consumo (
      ingrediente_id BIGINT UNSIGNED PRIMARY KEY,
      cantidad_total DECIMAL(14,3) NOT NULL
    ) ENGINE=MEMORY;
    TRUNCATE TABLE tmp_consumo;

    INSERT INTO tmp_consumo(ingrediente_id, cantidad_total)
    SELECT r.ingrediente_id, SUM(r.cantidad * pi.cantidad)
    FROM pedido_item pi
    JOIN receta_item r ON r.plato_id = pi.plato_id
    WHERE pi.pedido_id = p_pedido_id
    GROUP BY r.ingrediente_id
    ON DUPLICATE KEY UPDATE cantidad_total = cantidad_total + VALUES(cantidad_total);

    INSERT INTO tmp_consumo(ingrediente_id, cantidad_total)
    SELECT pie.ingrediente_id, SUM(pie.cantidad)
    FROM pedido_item pi
    JOIN pedido_item_extra pie ON pie.pedido_item_id = pi.pedido_item_id
    WHERE pi.pedido_id = p_pedido_id
    GROUP BY pie.ingrediente_id
    ON DUPLICATE KEY UPDATE cantidad_total = cantidad_total + VALUES(cantidad_total);

    -- Bloquear inventario involucrado
    SELECT inv.ingrediente_id FROM inventario inv JOIN tmp_consumo t ON t.ingrediente_id=inv.ingrediente_id FOR UPDATE;

    -- Validar stock suficiente
    IF EXISTS (
      SELECT 1 FROM tmp_consumo t
      LEFT JOIN inventario inv ON inv.ingrediente_id = t.ingrediente_id
      WHERE COALESCE(inv.stock_actual,0) < t.cantidad_total
    ) THEN
      DROP TEMPORARY TABLE IF EXISTS tmp_consumo;
      ROLLBACK; SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Stock insuficiente';
    END IF;

    -- Descontar stock
    UPDATE inventario inv
    JOIN tmp_consumo t ON t.ingrediente_id = inv.ingrediente_id
    SET inv.stock_actual = inv.stock_actual - t.cantidad_total;

    DROP TEMPORARY TABLE IF EXISTS tmp_consumo;

    -- Actualizar estado con bypass
    SET @bypass_entrega = 1;
    UPDATE pedidos
      SET estado = 'ENTREGADO', entregado_por_sub = p_usuario_sub, actualizado_en = NOW()
      WHERE pedido_id = p_pedido_id;
    SET @bypass_entrega = NULL;

  ELSE
    UPDATE pedidos
      SET estado = p_estado_nuevo, actualizado_en = NOW()
      WHERE pedido_id = p_pedido_id;
  END IF;

  COMMIT;
END $$
DELIMITER ;

-- =====================
-- Ejemplos de uso
-- =====================
-- 1) Compra: el trigger suma a inventario
-- INSERT INTO compra(proveedor_id, referencia, creado_por_sub) VALUES (1,'FAC-0002','sub-abc');
-- SET @c := LAST_INSERT_ID();
-- INSERT INTO compra_item(compra_id, ingrediente_id, cantidad, costo_unitario)
-- SELECT @c, ingrediente_id, cant, costo FROM (
--   SELECT 'CARNE' cod, 2.5 cant, 5.20 costo UNION ALL
--   SELECT 'QUESO',  1.0, 6.00
-- ) x JOIN ingredientes i ON i.codigo=x.cod;

-- 2) Cambiar estados:
-- CALL sp_pedido_cambiar_estado(@p,'EN_COCINA','sub-abc');
-- CALL sp_pedido_cambiar_estado(@p,'LISTO','sub-abc');
-- CALL sp_pedido_cambiar_estado(@p,'ENTREGADO','sub-abc');

use fastfood;

